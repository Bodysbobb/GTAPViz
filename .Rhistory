} else {
message(sprintf("Skipping %s-WEL.har (file not found)", scenario))
return(NULL)
}
}),
valid_cases
)
har.data.raw <- har.data.raw[!sapply(har.data.raw, is.null)]
if (length(har.data.raw) > 0) {
har_data <- do.call(
HARplus::get_data_by_var,
c(
list(
experiment_names = names(har.data.raw),
subtotal_level = TRUE,
merge_data = TRUE
),
har.data.raw
)
)
har_data <- add_mapping_info(har_data, harmap, mapping = info.mode)
processed_decomp <- lapply(har_data, function(df) {
if ("A" %in% df$Header) {
welfare_decomp <- df[df$Header == "A", ]
names(welfare_decomp)[names(welfare_decomp) == "COLUMN"] <- "Component"
welfare_totals <- stats::aggregate(
Value ~ REG + Experiment + Header + Description + Unit,
data = welfare_decomp,
FUN = sum
)
welfare_totals$Component <- "Total"
welfare_decomp <- rbind(welfare_decomp, welfare_totals)
df[df$Header == "A", ] <- welfare_decomp
}
return(df)
})
decomposition_data <- list(Decomposition = processed_decomp)
HARplus::export_data(
data = decomposition_data,
output_path = output.folder,
format = output_formats,
create_subfolder = TRUE,
multi_sheet_xlsx = TRUE,
report_output = TRUE
)
}
}
if (file.exists(output.folder)) {
.consolidate_reports(
output_folder = output.folder,
final_name = "Report_Output.xlsx",
remove_sources = TRUE
)
}
message("GTAP data processing completed!")
invisible(NULL)
}
# ==============================================================================
# DO NOT EDIT BELOW THIS LINE
# ==============================================================================
# Load Input Data from Excel Mapping File
mapping.output <- paste0(map.folder, "/OutputMapping.xlsx")
sl4map <- read_xlsx(mapping.output, sheet = "SL4File")
harmap <- read_xlsx(mapping.output, sheet = "HARFile")
process_gtap_data(
sl4map = sl4map,
harmap = harmap,
case.name = case.name,
info.mode = info.mode,
)
#' @title Create Decomposition Table from HAR Data
#' @description Transforms decomposition data from long to wide format with flexible column selection
#' and optional total calculation.
#'
#' @param data A data frame or list from get_data functions containing HAR file data
#' @param header Character. The header to process (e.g., "A" for welfare decomposition)
#' @param wide_cols Character vector. Column names to be converted to wide format
#' @param total_column Logical. If TRUE, adds a total column summing across numeric columns
#'
#' @return A data frame in wide format with decomposition components
#' @export
#'
#' @examples
#' # Load HAR data
#' har_data <- load_harx("path/to/har/file.har")
#'
#' # Get data using get_data_by_var
#' extracted_data <- get_data_by_var(var_names = c("A"), har_data)
#'
#' # Create decomposition table for welfare (A header)
#' # Converting COLUMN to wide format
#' decomp_table(extracted_data,
#'             header = "A",
#'             wide_cols = "COLUMN",
#'             total_column = TRUE)
#'
decomp_table <- function(data, header, wide_cols, total_column = FALSE) {
# Input validation
if (missing(data) || is.null(data)) {
stop("Data input is required")
}
if (missing(header) || is.null(header)) {
stop("Header specification is required")
}
if (missing(wide_cols) || is.null(wide_cols)) {
stop("Column(s) for wide format conversion must be specified")
}
# Handle different input types (list vs data frame)
if (is.list(data) && !is.data.frame(data)) {
if (header %in% names(data)) {
df <- data[[header]]
} else {
stop(sprintf("Header '%s' not found in data", header))
}
} else if (is.data.frame(data)) {
if ("Header" %in% names(data)) {
df <- data[data$Header == header, ]
} else {
df <- data  # Assume the data frame is already filtered for the desired header
}
} else {
stop("Input data must be a data frame or list")
}
# Validate wide_cols exist in data
missing_cols <- wide_cols[!wide_cols %in% names(df)]
if (length(missing_cols) > 0) {
stop(sprintf("Column(s) not found in data: %s",
paste(missing_cols, collapse = ", ")))
}
# Ensure 'Experiment' is the first column in the result
if (!"Experiment" %in% names(df)) {
stop("Data must contain an 'Experiment' column")
}
# Identify columns to keep in long format
keep_cols <- setdiff(names(df), c(wide_cols, "Value"))
# Reshape data to wide format
wide_data <- reshape(df,
direction = "wide",
timevar = wide_cols,
idvar = keep_cols,
v.names = "Value")
# Clean up column names - remove "Value." prefix
new_names <- sub("^Value\\.", "", names(wide_data))
names(wide_data) <- new_names
# Reorder columns to ensure Experiment is first
all_cols <- names(wide_data)
experiment_col <- which(all_cols == "Experiment")
col_order <- c(all_cols[experiment_col],
all_cols[-experiment_col])
wide_data <- wide_data[, col_order]
# Add total column if requested
if (total_column) {
# Identify numeric columns (excluding Experiment and other non-numeric columns)
numeric_cols <- sapply(wide_data, is.numeric)
if (any(numeric_cols)) {
wide_data$Total <- rowSums(wide_data[, numeric_cols], na.rm = TRUE)
} else {
warning("No numeric columns found for total calculation")
}
}
# Return the final data frame
return(wide_data)
}
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A",har1)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A",har1,merge_data = TRUE)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A",har1)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har1 <- get_data_by_var("A",har1)
View(har1)
View(har1[["har1"]][["A"]])
result <- decomp_table(
data = har1[["har1"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(har1)
decomp_table <- function(data, header, wide_cols, total_column = FALSE) {
if (missing(data) || is.null(data)) stop("Data input is required")
if (missing(header) || is.null(header)) stop("Header specification is required")
if (missing(wide_cols) || is.null(wide_cols)) stop("Column(s) for wide format conversion must be specified")
find_df <- function(x, header) {
if (is.data.frame(x)) {
if ("Header" %in% names(x)) {
if (header %in% unique(x$Header)) return(x[x$Header == header, ])
} else {
return(x)
}
} else if (is.list(x)) {
if (header %in% names(x)) {
res <- find_df(x[[header]], header)
if (!is.null(res)) return(res)
}
res <- lapply(x, find_df, header = header)
res <- Filter(Negate(is.null), res)
if (length(res) > 0) return(res[[1]])
}
return(NULL)
}
df <- if (is.data.frame(data)) {
if ("Header" %in% names(data)) {
if (header %in% unique(data$Header)) data[data$Header == header, ] else data
} else {
data
}
} else if (is.list(data)) {
find_df(data, header)
} else {
stop("Input data must be a data frame or list")
}
if (is.null(df)) stop(sprintf("Header '%s' not found in data", header))
missing_cols <- wide_cols[!wide_cols %in% names(df)]
if (length(missing_cols) > 0) {
stop(sprintf("Column(s) not found in data: %s", paste(missing_cols, collapse = ", ")))
}
if (!"Experiment" %in% names(df)) stop("Data must contain an 'Experiment' column")
keep_cols <- setdiff(names(df), c(wide_cols, "Value"))
wide_data <- reshape(df,
direction = "wide",
timevar = wide_cols,
idvar = keep_cols,
v.names = "Value")
names(wide_data) <- sub("^Value\\.", "", names(wide_data))
all_cols <- names(wide_data)
experiment_col <- which(all_cols == "Experiment")
wide_data <- wide_data[, c(all_cols[experiment_col], all_cols[-experiment_col])]
if (total_column) {
numeric_cols <- sapply(wide_data, is.numeric)
if (any(numeric_cols)) {
wide_data$Total <- rowSums(wide_data[, numeric_cols, drop = FALSE], na.rm = TRUE)
} else {
warning("No numeric columns found for total calculation")
}
}
return(wide_data)
}
result <- decomp_table(
data = har1[["har1"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
# Example usage for welfare decomposition (A header)
result <- decomp_table(
data = har[["har"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har)
View(har)
result <- decomp_table(
data = har,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
View(har)
result <- decomp_table(
data = har,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(har)
decomp_table <- function(data, header, wide_cols, total_column = FALSE) {
if (missing(data) || is.null(data)) stop("Data input is required")
if (missing(header) || is.null(header)) stop("Header specification is required")
if (missing(wide_cols) || is.null(wide_cols)) stop("Column(s) for wide format conversion must be specified")
process_df <- function(df) {
if ("Header" %in% names(df)) {
if (!(header %in% unique(df$Header))) return(NULL)
df <- df[df$Header == header, ]
}
if (!"Experiment" %in% names(df)) stop("Data must contain an 'Experiment' column")
missing_cols <- wide_cols[!wide_cols %in% names(df)]
if (length(missing_cols) > 0) stop(sprintf("Column(s) not found in data: %s", paste(missing_cols, collapse = ", ")))
keep_cols <- setdiff(names(df), c(wide_cols, "Value"))
wide_data <- reshape(df, direction = "wide", timevar = wide_cols, idvar = keep_cols, v.names = "Value")
names(wide_data) <- sub("^Value\\.", "", names(wide_data))
all_cols <- names(wide_data)
experiment_col <- which(all_cols == "Experiment")
wide_data <- wide_data[, c(all_cols[experiment_col], all_cols[-experiment_col])]
if (total_column) {
numeric_cols <- sapply(wide_data, is.numeric)
if (any(numeric_cols)) {
wide_data$Total <- rowSums(wide_data[, numeric_cols, drop = FALSE], na.rm = TRUE)
} else {
warning("No numeric columns found for total calculation")
}
}
return(wide_data)
}
process_element <- function(x) {
if (is.data.frame(x)) {
res <- process_df(x)
return(if (!is.null(res)) res else x)
} else if (is.list(x)) {
return(lapply(x, process_element))
} else {
return(x)
}
}
process_element(data)
}
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
# Example usage for welfare decomposition (A header)
result <- decomp_table(
data = har[["har"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
result <- decomp_table(
data = har,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(result[["har1"]][["A"]])
result <- decomp_table(
data = har1[["har1"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A", har1)
har1 <- get_data_by_var("A", har1, har2, merge_data = TRUE)
View(har1)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(result[["A"]])
rm(list=ls())
packages <- c("tidyverse", "writexl", "dplyr", "devtools",
"openxlsx", "readxl", "knitr", "rmarkdown", "data.table",
"ggplot2", "tcltk", "gridExtra", "haven", "citation", "tinytex", "bookdown")
install.packages(setdiff(packages, rownames(installed.packages())))
lapply(packages, library, character.only = TRUE)
library(haven)
library(data.table)
input.dir <- "D:/One Drive/OneDrive - purdue.edu/Koustuv"
output.dir <- input.dir
readRDS(paste0(input.dir,"TCL.rds"))
library(haven)
library(data.table)
input.dir <- "D:/One Drive/OneDrive - purdue.edu/Koustuv"
output.dir <- input.dir
readRDS(paste0(input.dir,"/TCL.rds"))
# Convert to data.table for more efficient processing
setDT(TCL)
TCL <- readRDS(paste0(input.dir,"/TCL.rds"))
# Convert to data.table for more efficient processing
setDT(TCL)
# Get unique years
unique_years <- unique(TCL$year)
# Loop through years
for (yr in unique_years) {
# Subset data for current year using data.table syntax
year_data <- TCL[year == yr]
# Create filename
filename <- file.path(output.dir, paste0("TCL_", yr, ".dta"))
# Export to Stata format
write_dta(year_data, filename)
# Clear the year_data object to free memory
rm(year_data)
gc()
# Print progress and memory usage
cat("Exported data for year:", yr,
"/nMemory used:", memory.size(), "MB/n/n")
}
colnames(TCL)
TCL.filter <- TCL[, .(
year = year,
country = area,
cpc_code = item_code__cpc_,
product = item,
type = element,
unit = unit,
value = value
)]
unique(TCL.filter$type)
a <- TCL.filter %>%
filter(country == "China")
View(a)
a <- TCL.filter %>%
filter(country == "India")
View(a)
# 1. Filter specific years
years_to_keep <- c(1996:1999, 2004:2007, 2011, 2012, 2015:2017, 2019, 2020)
TCL_filter <- TCL.filter[year %in% years_to_keep]
# 2. Calculate total sum by year, unit, and type
TCL_filter[, total := sum(value, na.rm = TRUE),
by = .(year, unit, type)]
# 3. Calculate total excluding India
TCL_filter[, total_excl_India := sum(value[country != "India"], na.rm = TRUE),
by = .(year, unit, type)]
filename <- file.path(output.dir, "TCL_filtered.dta")
write_dta(TCL_filter, filename)
# Get unique years
unique_years <- unique(TCL.filter$year)
# 2. Calculate total sum by year, unit, and type
TCL.filter[, total := sum(value, na.rm = TRUE),
by = .(year, unit, type)]
# 3. Calculate total excluding India
TCL.filter[, total_excl_India := sum(value[country != "India"], na.rm = TRUE),
by = .(year, unit, type)]
# Loop through years
for (yr in unique_years) {
# Subset data for current year using data.table syntax
year_data <- TCL.filter[year == yr]
# Create filename
filename <- file.path(output.dir, paste0("TCL_", yr, ".dta"))
# Export to Stata format
write_dta(year_data, filename)
# Clear the year_data object to free memory
rm(year_data)
gc()
# Print progress and memory usage
cat("Exported data for year:", yr,
"/nMemory used:", memory.size(), "MB/n/n")
}
# 4. Calculate total excluding India and at product level
TCL_filter[, total_excl_India_product := sum(value[country != "India"], na.rm = TRUE),
by = .(year, unit, type, product)]
filename <- file.path(output.dir, "TCL_filtered.dta")
write_dta(TCL_filter, filename)
rm(list=ls())
# Load required libraries
packages <- c("tidyverse", "writexl", "dplyr",
"openxlsx", "readxl", "data.table", "haven")
install.packages(setdiff(packages, rownames(installed.packages())))
lapply(packages, library, character.only = TRUE)
input.dir <- "D:/One Drive/OneDrive - purdue.edu/Koustuv"
output.dir <- input.dir
TCL <- readRDS(paste0(input.dir,"/TCL.rds"))
# Convert to data.table for more efficient processing
setDT(TCL)
# Removing unnecessary column and rename
TCL.filter <- TCL[, .(
year = year,
country = area,
cpc_code = item_code__cpc_,
product = item,
type = element,
unit = unit,
value = value
)]
# 1. Filter specific years
years_to_keep <- c(1996:1999, 2004:2007, 2011, 2012, 2015:2017, 2019, 2020)
TCL_filter <- TCL.filter[year %in% years_to_keep]
# 2. Calculate total sum by year, unit, and type
TCL_filter[, total := sum(value, na.rm = TRUE),
by = .(year, unit, type)]
product <- TCL_filter %>%
select(product) %>%
distinct()
View(product)
product <- TCL_filter %>%
select(product, cpc_code) %>%
distinct()
View(product)
