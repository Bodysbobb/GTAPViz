}
if (!dir.exists(output.folder)) {
dir.create(output.folder, recursive = TRUE)
}
validation_result <- .validate_gtap_files(
input.folder  = input.folder,
output.folder = output.folder,
map.folder    = map.folder,
case.name     = case.name,
info.mode     = info.mode,
sl4map        = sl4map,
harmap        = harmap,
output_formats = output_formats
)
cat(paste(validation_result$messages, collapse = "\n"), "\n")
if (!validation_result$proceed) {
stop("Process stopped due to validation errors.")
}
if (validation_result$status != "ok") {
message("Proceeding with available files as per user confirmation...")
}
files <- list.files(input.folder, full.names = FALSE, ignore.case = TRUE)
sl4_files <- files[grepl("\\.sl4$", files, ignore.case = TRUE)]
har_files <- files[grepl("-wel\\.har$", files, ignore.case = TRUE)]
sl4_bases <- tolower(trimws(sub("\\.sl4$", "", sl4_files, ignore.case = TRUE)))
har_bases <- tolower(trimws(sub("-wel\\.har$", "", har_files, ignore.case = TRUE)))
valid_cases <- case.name[tolower(case.name) %in% union(sl4_bases, har_bases)]
if (length(sl4map$Variable) > 0) {
sl4.data.raw <- setNames(
lapply(valid_cases, function(scenario) {
sl4_path <- file.path(input.folder, paste0(scenario, ".sl4"))
if (file.exists(sl4_path)) {
tryCatch({
HARplus::load_sl4x(sl4_path, select_header = sl4map$Variable)
}, error = function(e) {
message(sprintf("Error processing %s.sl4: %s", scenario, e$message))
return(NULL)
})
} else {
message(sprintf("Skipping %s.sl4 (file not found)", scenario))
return(NULL)
}
}),
valid_cases
)
sl4.data.raw <- sl4.data.raw[!sapply(sl4.data.raw, is.null)]
if (length(sl4.data.raw) > 0) {
has_only_macros <- all(tolower(sl4map$Variable) %in% "macros", na.rm = TRUE)
if (!has_only_macros) {
priority_list <- list(
"Sector" = c("COMM", "ACTS"),
"Region" = c("REG")
)
grouped_sl4 <- tryCatch({
do.call(
HARplus::group_data_by_dims,
c(
list(
experiment_names = names(sl4.data.raw),
auto_rename = TRUE,
priority = priority_list,
subtotal_level = TRUE
),
sl4.data.raw
)
)
}, error = function(e) {
message(sprintf("Error in grouping SL4 data: %s", e$message))
return(NULL)
})
if (!is.null(grouped_sl4)) {
if ("3D" %in% names(grouped_sl4)) {
bilateral_patterns <- grep("COMM.*REG.*REG",
names(grouped_sl4[["3D"]]),
value = TRUE)
if (length(bilateral_patterns) > 0) {
for (pattern in bilateral_patterns) {
df <- grouped_sl4[["3D"]][[pattern]]
if ("REG" %in% names(df) && "REG.1" %in% names(df)) {
names(df)[names(df) == "REG"] <- "Source"
names(df)[names(df) == "REG.1"] <- "Destination"
grouped_sl4[["3D"]][[pattern]] <- df
}
}
}
}
grouped_sl4 <- add_mapping_info(grouped_sl4, sl4map, mapping = info.mode)
if (any(grepl("qxs", sl4map$Variable, ignore.case = TRUE))) {
grouped_sl4 <- .process_bilateral_trade(
grouped_sl4,
output.folder,
output_formats
)
}
HARplus::export_data(
data = grouped_sl4,
output_path = output.folder,
format = output_formats,
create_subfolder = TRUE,
multi_sheet_xlsx = TRUE,
report_output = TRUE
)
}
}
if (any(tolower(sl4map$Variable) %in% "macros", na.rm = TRUE)) {
available_sl4_files <- file.path(input.folder, paste0(valid_cases, ".sl4"))
available_sl4_files <- available_sl4_files[file.exists(available_sl4_files)]
if (length(available_sl4_files) > 0) {
.process_macro_data(
input_files = available_sl4_files,
experiment_names = tools::file_path_sans_ext(basename(available_sl4_files)),
output_path = output.folder,
formats = output_formats
)
}
}
}
}
if (length(harmap$Variable) > 0) {
har.data.raw <- setNames(
lapply(valid_cases, function(scenario) {
har_path <- file.path(input.folder, paste0(scenario, "-WEL.har"))
if (file.exists(har_path)) {
tryCatch({
HARplus::load_harx(har_path, select_header = harmap$Variable)
}, error = function(e) {
message(sprintf("Error processing %s-WEL.har: %s", scenario, e$message))
return(NULL)
})
} else {
message(sprintf("Skipping %s-WEL.har (file not found)", scenario))
return(NULL)
}
}),
valid_cases
)
har.data.raw <- har.data.raw[!sapply(har.data.raw, is.null)]
if (length(har.data.raw) > 0) {
har_data <- do.call(
HARplus::get_data_by_var,
c(
list(
experiment_names = names(har.data.raw),
subtotal_level = TRUE,
merge_data = TRUE
),
har.data.raw
)
)
har_data <- add_mapping_info(har_data, harmap, mapping = info.mode)
processed_decomp <- lapply(har_data, function(df) {
if ("A" %in% df$Header) {
welfare_decomp <- df[df$Header == "A", ]
names(welfare_decomp)[names(welfare_decomp) == "COLUMN"] <- "Component"
welfare_totals <- stats::aggregate(
Value ~ REG + Experiment + Header + Description + Unit,
data = welfare_decomp,
FUN = sum
)
welfare_totals$Component <- "Total"
welfare_decomp <- rbind(welfare_decomp, welfare_totals)
df[df$Header == "A", ] <- welfare_decomp
}
return(df)
})
decomposition_data <- list(Decomposition = processed_decomp)
HARplus::export_data(
data = decomposition_data,
output_path = output.folder,
format = output_formats,
create_subfolder = TRUE,
multi_sheet_xlsx = TRUE,
report_output = TRUE
)
}
}
if (file.exists(output.folder)) {
.consolidate_reports(
output_folder = output.folder,
final_name = "Report_Output.xlsx",
remove_sources = TRUE
)
}
message("GTAP data processing completed!")
invisible(NULL)
}
# ==============================================================================
# DO NOT EDIT BELOW THIS LINE
# ==============================================================================
# Load Input Data from Excel Mapping File
mapping.output <- paste0(map.folder, "/OutputMapping.xlsx")
sl4map <- read_xlsx(mapping.output, sheet = "SL4File")
harmap <- read_xlsx(mapping.output, sheet = "HARFile")
process_gtap_data(
sl4map = sl4map,
harmap = harmap,
case.name = case.name,
info.mode = info.mode,
)
#' @title Create Decomposition Table from HAR Data
#' @description Transforms decomposition data from long to wide format with flexible column selection
#' and optional total calculation.
#'
#' @param data A data frame or list from get_data functions containing HAR file data
#' @param header Character. The header to process (e.g., "A" for welfare decomposition)
#' @param wide_cols Character vector. Column names to be converted to wide format
#' @param total_column Logical. If TRUE, adds a total column summing across numeric columns
#'
#' @return A data frame in wide format with decomposition components
#' @export
#'
#' @examples
#' # Load HAR data
#' har_data <- load_harx("path/to/har/file.har")
#'
#' # Get data using get_data_by_var
#' extracted_data <- get_data_by_var(var_names = c("A"), har_data)
#'
#' # Create decomposition table for welfare (A header)
#' # Converting COLUMN to wide format
#' decomp_table(extracted_data,
#'             header = "A",
#'             wide_cols = "COLUMN",
#'             total_column = TRUE)
#'
decomp_table <- function(data, header, wide_cols, total_column = FALSE) {
# Input validation
if (missing(data) || is.null(data)) {
stop("Data input is required")
}
if (missing(header) || is.null(header)) {
stop("Header specification is required")
}
if (missing(wide_cols) || is.null(wide_cols)) {
stop("Column(s) for wide format conversion must be specified")
}
# Handle different input types (list vs data frame)
if (is.list(data) && !is.data.frame(data)) {
if (header %in% names(data)) {
df <- data[[header]]
} else {
stop(sprintf("Header '%s' not found in data", header))
}
} else if (is.data.frame(data)) {
if ("Header" %in% names(data)) {
df <- data[data$Header == header, ]
} else {
df <- data  # Assume the data frame is already filtered for the desired header
}
} else {
stop("Input data must be a data frame or list")
}
# Validate wide_cols exist in data
missing_cols <- wide_cols[!wide_cols %in% names(df)]
if (length(missing_cols) > 0) {
stop(sprintf("Column(s) not found in data: %s",
paste(missing_cols, collapse = ", ")))
}
# Ensure 'Experiment' is the first column in the result
if (!"Experiment" %in% names(df)) {
stop("Data must contain an 'Experiment' column")
}
# Identify columns to keep in long format
keep_cols <- setdiff(names(df), c(wide_cols, "Value"))
# Reshape data to wide format
wide_data <- reshape(df,
direction = "wide",
timevar = wide_cols,
idvar = keep_cols,
v.names = "Value")
# Clean up column names - remove "Value." prefix
new_names <- sub("^Value\\.", "", names(wide_data))
names(wide_data) <- new_names
# Reorder columns to ensure Experiment is first
all_cols <- names(wide_data)
experiment_col <- which(all_cols == "Experiment")
col_order <- c(all_cols[experiment_col],
all_cols[-experiment_col])
wide_data <- wide_data[, col_order]
# Add total column if requested
if (total_column) {
# Identify numeric columns (excluding Experiment and other non-numeric columns)
numeric_cols <- sapply(wide_data, is.numeric)
if (any(numeric_cols)) {
wide_data$Total <- rowSums(wide_data[, numeric_cols], na.rm = TRUE)
} else {
warning("No numeric columns found for total calculation")
}
}
# Return the final data frame
return(wide_data)
}
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A",har1)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A",har1,merge_data = TRUE)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A",har1)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har1 <- get_data_by_var("A",har1)
View(har1)
View(har1[["har1"]][["A"]])
result <- decomp_table(
data = har1[["har1"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(har1)
decomp_table <- function(data, header, wide_cols, total_column = FALSE) {
if (missing(data) || is.null(data)) stop("Data input is required")
if (missing(header) || is.null(header)) stop("Header specification is required")
if (missing(wide_cols) || is.null(wide_cols)) stop("Column(s) for wide format conversion must be specified")
find_df <- function(x, header) {
if (is.data.frame(x)) {
if ("Header" %in% names(x)) {
if (header %in% unique(x$Header)) return(x[x$Header == header, ])
} else {
return(x)
}
} else if (is.list(x)) {
if (header %in% names(x)) {
res <- find_df(x[[header]], header)
if (!is.null(res)) return(res)
}
res <- lapply(x, find_df, header = header)
res <- Filter(Negate(is.null), res)
if (length(res) > 0) return(res[[1]])
}
return(NULL)
}
df <- if (is.data.frame(data)) {
if ("Header" %in% names(data)) {
if (header %in% unique(data$Header)) data[data$Header == header, ] else data
} else {
data
}
} else if (is.list(data)) {
find_df(data, header)
} else {
stop("Input data must be a data frame or list")
}
if (is.null(df)) stop(sprintf("Header '%s' not found in data", header))
missing_cols <- wide_cols[!wide_cols %in% names(df)]
if (length(missing_cols) > 0) {
stop(sprintf("Column(s) not found in data: %s", paste(missing_cols, collapse = ", ")))
}
if (!"Experiment" %in% names(df)) stop("Data must contain an 'Experiment' column")
keep_cols <- setdiff(names(df), c(wide_cols, "Value"))
wide_data <- reshape(df,
direction = "wide",
timevar = wide_cols,
idvar = keep_cols,
v.names = "Value")
names(wide_data) <- sub("^Value\\.", "", names(wide_data))
all_cols <- names(wide_data)
experiment_col <- which(all_cols == "Experiment")
wide_data <- wide_data[, c(all_cols[experiment_col], all_cols[-experiment_col])]
if (total_column) {
numeric_cols <- sapply(wide_data, is.numeric)
if (any(numeric_cols)) {
wide_data$Total <- rowSums(wide_data[, numeric_cols, drop = FALSE], na.rm = TRUE)
} else {
warning("No numeric columns found for total calculation")
}
}
return(wide_data)
}
result <- decomp_table(
data = har1[["har1"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
# Example usage for welfare decomposition (A header)
result <- decomp_table(
data = har[["har"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har)
View(har)
result <- decomp_table(
data = har,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
View(har)
result <- decomp_table(
data = har,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(har)
decomp_table <- function(data, header, wide_cols, total_column = FALSE) {
if (missing(data) || is.null(data)) stop("Data input is required")
if (missing(header) || is.null(header)) stop("Header specification is required")
if (missing(wide_cols) || is.null(wide_cols)) stop("Column(s) for wide format conversion must be specified")
process_df <- function(df) {
if ("Header" %in% names(df)) {
if (!(header %in% unique(df$Header))) return(NULL)
df <- df[df$Header == header, ]
}
if (!"Experiment" %in% names(df)) stop("Data must contain an 'Experiment' column")
missing_cols <- wide_cols[!wide_cols %in% names(df)]
if (length(missing_cols) > 0) stop(sprintf("Column(s) not found in data: %s", paste(missing_cols, collapse = ", ")))
keep_cols <- setdiff(names(df), c(wide_cols, "Value"))
wide_data <- reshape(df, direction = "wide", timevar = wide_cols, idvar = keep_cols, v.names = "Value")
names(wide_data) <- sub("^Value\\.", "", names(wide_data))
all_cols <- names(wide_data)
experiment_col <- which(all_cols == "Experiment")
wide_data <- wide_data[, c(all_cols[experiment_col], all_cols[-experiment_col])]
if (total_column) {
numeric_cols <- sapply(wide_data, is.numeric)
if (any(numeric_cols)) {
wide_data$Total <- rowSums(wide_data[, numeric_cols, drop = FALSE], na.rm = TRUE)
} else {
warning("No numeric columns found for total calculation")
}
}
return(wide_data)
}
process_element <- function(x) {
if (is.data.frame(x)) {
res <- process_df(x)
return(if (!is.null(res)) res else x)
} else if (is.list(x)) {
return(lapply(x, process_element))
} else {
return(x)
}
}
process_element(data)
}
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
# Example usage for welfare decomposition (A header)
result <- decomp_table(
data = har[["har"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
har1 <- load_harx(paste0(input.folder,"/EXP1-WEL.har"))
har2 <- load_harx(paste0(input.folder,"/EXP2-WEL.har"))
har <- get_data_by_var("A", har1, har2)
result <- decomp_table(
data = har,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(result[["har1"]][["A"]])
result <- decomp_table(
data = har1[["har1"]],
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(har1)
har1 <- get_data_by_var("A", har1)
har1 <- get_data_by_var("A", har1, har2, merge_data = TRUE)
View(har1)
result <- decomp_table(
data = har1,
header = "A",
wide_cols = "COLUMN",  # This will convert the COLUMN values to separate columns
total_column = TRUE    # Add a total column
)
View(result)
View(result[["A"]])
